"use strict";
exports.id = 8792;
exports.ids = [8792];
exports.modules = {

/***/ 45708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Mailchimp Transactional API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.50
 * Contact: apihelp@mailchimp.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 2.4.12
 *
 * Do not edit the class manually.
 *
 */ 
var axios = __webpack_require__(43956);
axios.defaults.timeout = 300000; // 300s
var Allowlists = __webpack_require__(22565);
var Exports = __webpack_require__(99606);
var Inbound = __webpack_require__(33592);
var Ips = __webpack_require__(14569);
var Messages = __webpack_require__(18849);
var Metadata = __webpack_require__(56113);
var Rejects = __webpack_require__(41582);
var Senders = __webpack_require__(11740);
var Subaccounts = __webpack_require__(57833);
var Tags = __webpack_require__(97045);
var Templates = __webpack_require__(56802);
var Urls = __webpack_require__(92929);
var Users = __webpack_require__(18894);
var Webhooks = __webpack_require__(5597);
var Whitelists = __webpack_require__(38226);
var exports = function(apiKey = "") {
    this.basePath = "https://mandrillapp.com/api/1.0";
    this.apiKey = apiKey;
    this.defaultOutputFormat = "";
    this.formatList = [
        "json",
        "xml",
        "php",
        "yaml"
    ];
    this.contentTypes = [
        "application/json"
    ];
    this.accepts = [
        "application/json",
        "application/xml",
        "application/x-php",
        "application/x-yaml; charset=utf-8"
    ];
    // API Routes
    this.allowlists = new Allowlists(this);
    this.exports = new Exports(this);
    this.inbound = new Inbound(this);
    this.ips = new Ips(this);
    this.messages = new Messages(this);
    this.metadata = new Metadata(this);
    this.rejects = new Rejects(this);
    this.senders = new Senders(this);
    this.subaccounts = new Subaccounts(this);
    this.tags = new Tags(this);
    this.templates = new Templates(this);
    this.urls = new Urls(this);
    this.users = new Users(this);
    this.webhooks = new Webhooks(this);
    this.whitelists = new Whitelists(this);
};
// HTTP POST request helper
exports.prototype.post = function post(path, body = {}) {
    var _this = this;
    var url = _this.basePath + path;
    // apply API key to the request
    body.key = _this.apiKey;
    // apply response format modifier
    var formatList = _this.formatList;
    var useDefaultOutputFormat = true;
    if (typeof body.outputFormat === "string") {
        var format = body.outputFormat.toLowerCase();
        if (formatList.indexOf(format) !== -1) {
            url = url + "." + format;
            delete body.outputFormat;
            useDefaultOutputFormat = false;
        }
    }
    // or use the default response format
    var defaultOutputFormat = _this.defaultOutputFormat;
    if (useDefaultOutputFormat && formatList.indexOf(defaultOutputFormat) !== -1) {
        url = url + "." + defaultOutputFormat;
    }
    return axios.post(url, body).then(function(response) {
        return response.data;
    }).catch(function(error) {
        return error;
    });
};
// Updates the default HTTP request response format (json, xml, php, yaml)
exports.prototype.setDefaultOutputFormat = function(outputFormat) {
    var _this = this;
    if (_this.formatList.indexOf(outputFormat) !== -1) {
        _this.defaultOutputFormat = outputFormat;
    }
};
exports.prototype.setDefaultTimeoutMs = function(timeoutMs) {
    axios.defaults.timeout = timeoutMs;
};
// The default API client implementation.
exports.instance = function(apiKey) {
    return new exports(apiKey);
};
module.exports = exports;


/***/ }),

/***/ 22565:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add email to allowlist
   * Adds an email to your email rejection allowlist. If the address is currently on your denylist, that denylist entry will be removed automatically.
   */ this.add = function(body) {
        return this.apiClient.post("/allowlists/add", body);
    };
    /**
   * Remove email from allowlist
   * Removes an email address from the allowlist.
   */ this.delete = function(body) {
        return this.apiClient.post("/allowlists/delete", body);
    };
    /**
   * List allowlisted emails
   * Retrieves your email rejection allowlist. You can provide an email address or search prefix to limit the results. Returns up to 1000 results.
   */ this.list = function(body) {
        return this.apiClient.post("/allowlists/list", body);
    };
};


/***/ }),

/***/ 99606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Export activity history
   * Begins an export of your activity history. The activity will be exported to a zip archive containing a single file named activity.csv in the same format as you would be able to export from your account's activity view. It includes the following fields: Date, Email Address, Sender, Subject, Status, Tags, Opens, Clicks, Bounce Detail. If you have configured any custom metadata fields, they will be included in the exported data.
   */ this.activity = function(body) {
        return this.apiClient.post("/exports/activity", body);
    };
    /**
   * Export Allowlist
   * Begins an export of your rejection allowlist. The allowlist will be exported to a zip archive containing a single file named allowlist.csv that includes the following fields: email, detail, created_at.
   */ this.allowlist = function(body) {
        return this.apiClient.post("/exports/allowlist", body);
    };
    /**
   * View export info
   * Returns information about an export job. If the export job's state is 'complete', the returned data will include a URL you can use to fetch the results. Every export job produces a zip archive, but the format of the archive is distinct for each job type. The api calls that initiate exports include more details about the output format for that job type.
   */ this.info = function(body) {
        return this.apiClient.post("/exports/info", body);
    };
    /**
   * List exports
   * Returns a list of your exports.
   */ this.list = function(body) {
        return this.apiClient.post("/exports/list", body);
    };
    /**
   * Export denylist
   * Begins an export of your rejection denylist. The denylist will be exported to a zip archive containing a single file named rejects.csv that includes the following fields: email, reason, detail, created_at, expires_at, last_event_at, expires_at.
   */ this.rejects = function(body) {
        return this.apiClient.post("/exports/rejects", body);
    };
    /**
   * Export Allowlist
   * Begins an export of your rejection allowlist. The allowlist will be exported to a zip archive containing a single file named allowlist.csv that includes the following fields: email, detail, created_at.
   */ this.whitelist = function(body) {
        return this.apiClient.post("/exports/whitelist", body);
    };
};


/***/ }),

/***/ 33592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add inbound domain
   * Add an inbound domain to your account.
   */ this.addDomain = function(body) {
        return this.apiClient.post("/inbound/add-domain", body);
    };
    /**
   * Add mailbox route
   * Add a new mailbox route to an inbound domain.
   */ this.addRoute = function(body) {
        return this.apiClient.post("/inbound/add-route", body);
    };
    /**
   * Check domain settings
   * Check the MX settings for an inbound domain. The domain must have already been added with the add-domain call.
   */ this.checkDomain = function(body) {
        return this.apiClient.post("/inbound/check-domain", body);
    };
    /**
   * Delete inbound domain
   * Delete an inbound domain from the account. All mail will stop routing for this domain immediately.
   */ this.deleteDomain = function(body) {
        return this.apiClient.post("/inbound/delete-domain", body);
    };
    /**
   * Delete mailbox route
   * Delete an existing inbound mailbox route.
   */ this.deleteRoute = function(body) {
        return this.apiClient.post("/inbound/delete-route", body);
    };
    /**
   * List inbound domains
   * List the domains that have been configured for inbound delivery.
   */ this.domains = function(body) {
        return this.apiClient.post("/inbound/domains", body);
    };
    /**
   * List mailbox routes
   * List the mailbox routes defined for an inbound domain.
   */ this.routes = function(body) {
        return this.apiClient.post("/inbound/routes", body);
    };
    /**
   * Send mime document
   * Take a raw MIME document destined for a domain with inbound domains set up, and send it to the inbound hook exactly as if it had been sent over SMTP.
   */ this.sendRaw = function(body) {
        return this.apiClient.post("/inbound/send-raw", body);
    };
    /**
   * Update mailbox route
   * Update the pattern or webhook of an existing inbound mailbox route. If null is provided for any fields, the values will remain unchanged.
   */ this.updateRoute = function(body) {
        return this.apiClient.post("/inbound/update-route", body);
    };
};


/***/ }),

/***/ 14569:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Cancel ip warmup
   * Cancels the warmup process for a dedicated IP.
   */ this.cancelWarmup = function(body) {
        return this.apiClient.post("/ips/cancel-warmup", body);
    };
    /**
   * Test custom dns
   * Tests whether a domain name is valid for use as the custom reverse DNS for a dedicated IP.
   */ this.checkCustomDns = function(body) {
        return this.apiClient.post("/ips/check-custom-dns", body);
    };
    /**
   * Add ip pool
   * Creates a pool and returns it. If a pool already exists with this name, no action will be performed.
   */ this.createPool = function(body) {
        return this.apiClient.post("/ips/create-pool", body);
    };
    /**
   * Delete ip address
   * Deletes a dedicated IP. This is permanent and cannot be undone.
   */ this.delete = function(body) {
        return this.apiClient.post("/ips/delete", body);
    };
    /**
   * Delete ip pool
   * Deletes a pool. A pool must be empty before you can delete it, and you cannot delete your default pool.
   */ this.deletePool = function(body) {
        return this.apiClient.post("/ips/delete-pool", body);
    };
    /**
   * Get ip info
   * Retrieves information about a single dedicated IP.
   */ this.info = function(body) {
        return this.apiClient.post("/ips/info", body);
    };
    /**
   * List ip addresses
   * Lists your dedicated IPs.
   */ this.list = function(body) {
        return this.apiClient.post("/ips/list", body);
    };
    /**
   * List ip pools
   * Lists your dedicated IP pools.
   */ this.listPools = function(body) {
        return this.apiClient.post("/ips/list-pools", body);
    };
    /**
   * Get ip pool info
   * Describes a single dedicated IP pool.
   */ this.poolInfo = function(body) {
        return this.apiClient.post("/ips/pool-info", body);
    };
    /**
   * Request additional ip
   * Requests an additional dedicated IP for your account. Accounts may have one outstanding request at any time, and provisioning requests are processed within 24 hours.
   */ this.provision = function(body) {
        return this.apiClient.post("/ips/provision", body);
    };
    /**
   * Set custom dns
   * Configures the custom DNS name for a dedicated IP.
   */ this.setCustomDns = function(body) {
        return this.apiClient.post("/ips/set-custom-dns", body);
    };
    /**
   * Move ip to different pool
   * Moves a dedicated IP to a different pool.
   */ this.setPool = function(body) {
        return this.apiClient.post("/ips/set-pool", body);
    };
    /**
   * Start ip warmup
   * Begins the warmup process for a dedicated IP. During the warmup process, the Transactional API will gradually increase the percentage of your mail that is sent over the warming-up IP, over a period of roughly 30 days. The rest of your mail will be sent over shared IPs or other dedicated IPs in the same pool.
   */ this.startWarmup = function(body) {
        return this.apiClient.post("/ips/start-warmup", body);
    };
};


/***/ }),

/***/ 18849:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Cancel scheduled email
   * Cancels a scheduled email.
   */ this.cancelScheduled = function(body) {
        return this.apiClient.post("/messages/cancel-scheduled", body);
    };
    /**
   * Get message content
   * Get the full content of a recently sent message.
   */ this.content = function(body) {
        return this.apiClient.post("/messages/content", body);
    };
    /**
   * Get message info
   * Get the information for a single recently sent message.
   */ this.info = function(body) {
        return this.apiClient.post("/messages/info", body);
    };
    /**
   * List scheduled emails
   * Queries your scheduled emails.
   */ this.listScheduled = function(body) {
        return this.apiClient.post("/messages/list-scheduled", body);
    };
    /**
   * Parse mime document
   * Parse the full MIME document for an email message, returning the content of the message broken into its constituent pieces.
   */ this.parse = function(body) {
        return this.apiClient.post("/messages/parse", body);
    };
    /**
   * Reschedule email
   * Reschedules a scheduled email.
   */ this.reschedule = function(body) {
        return this.apiClient.post("/messages/reschedule", body);
    };
    /**
   * Search messages by date
   * Search recently sent messages and optionally narrow by date range, tags, senders, and API keys. If no date range is specified, results within the last 7 days are returned. This method may be called up to 20 times per minute. If you need the data more often, you can use /messages/info.json to get the information for a single message, or webhooks to push activity to your own application for querying.
   */ this.search = function(body) {
        return this.apiClient.post("/messages/search", body);
    };
    /**
   * Search messages by hour
   * Search the content of recently sent messages and return the aggregated hourly stats for matching messages.
   */ this.searchTimeSeries = function(body) {
        return this.apiClient.post("/messages/search-time-series", body);
    };
    /**
   * Send new message
   * Send a new transactional message through the Transactional API.
   */ this.send = function(body) {
        return this.apiClient.post("/messages/send", body);
    };
    /**
   * Send mime document
   * Take a raw MIME document for a message, and send it exactly as if it were sent through the Transactional API's SMTP servers.
   */ this.sendRaw = function(body) {
        return this.apiClient.post("/messages/send-raw", body);
    };
    /**
   * Send using message template
   * Send a new transactional message through the Transactional API using a template.
   */ this.sendTemplate = function(body) {
        return this.apiClient.post("/messages/send-template", body);
    };
};


/***/ }),

/***/ 56113:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add metadata field
   * Add a new custom metadata field to be indexed for the account.
   */ this.add = function(body) {
        return this.apiClient.post("/metadata/add", body);
    };
    /**
   * Delete metadata field
   * Delete an existing custom metadata field. Deletion isn't instataneous, and /metadata/list will continue to return the field until the asynchronous deletion process is complete.
   */ this.delete = function(body) {
        return this.apiClient.post("/metadata/delete", body);
    };
    /**
   * List metadata fields
   * Get the list of custom metadata fields indexed for the account.
   */ this.list = function(body) {
        return this.apiClient.post("/metadata/list", body);
    };
    /**
   * Update metadata field
   * Update an existing custom metadata field.
   */ this.update = function(body) {
        return this.apiClient.post("/metadata/update", body);
    };
};


/***/ }),

/***/ 41582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add email to denylist
   * Adds an email to your email rejection denylist. Addresses that you add manually will never expire and there is no reputation penalty for removing them from your denylist. Attempting to denylist an address that has been added to the allowlist will have no effect.
   */ this.add = function(body) {
        return this.apiClient.post("/rejects/add", body);
    };
    /**
   * Delete email from denylist
   * Deletes an email rejection. There is no limit to how many rejections you can remove from your denylist, but keep in mind that each deletion has an affect on your reputation.
   */ this.delete = function(body) {
        return this.apiClient.post("/rejects/delete", body);
    };
    /**
   * List denylisted emails
   * Retrieves your email rejection denylist. You can provide an email address to limit the results. Returns up to 1000 results. By default, entries that have expired are excluded from the results; set include_expired to true to include them.
   */ this.list = function(body) {
        return this.apiClient.post("/rejects/list", body);
    };
};


/***/ }),

/***/ 11740:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add sender domain
   * Adds a sender domain to your account. Sender domains are added automatically as you send, but you can use this call to add them ahead of time.
   */ this.addDomain = function(body) {
        return this.apiClient.post("/senders/add-domain", body);
    };
    /**
   * Check domain settings
   * Checks the SPF and DKIM settings for a domain, as well the domain verification. If you haven't already added this domain to your account, it will be added automatically.
   */ this.checkDomain = function(body) {
        return this.apiClient.post("/senders/check-domain", body);
    };
    /**
   * List sender domains
   * Returns the sender domains that have been added to this account.
   */ this.domains = function(body) {
        return this.apiClient.post("/senders/domains", body);
    };
    /**
   * Get sender info
   * Return more detailed information about a single sender, including aggregates of recent stats.
   */ this.info = function(body) {
        return this.apiClient.post("/senders/info", body);
    };
    /**
   * List account senders
   * Return the senders that have tried to use this account.
   */ this.list = function(body) {
        return this.apiClient.post("/senders/list", body);
    };
    /**
   * View sender history
   * Return the recent history (hourly stats for the last 30 days) for a sender.
   */ this.timeSeries = function(body) {
        return this.apiClient.post("/senders/time-series", body);
    };
    /**
   * Verify domain
   * Sends a verification email in order to verify ownership of a domain. Domain verification is a required step to confirm ownership of a domain. Once a domain has been verified in a Transactional API account, other accounts may not have their messages signed by that domain unless they also verify the domain. This prevents other Transactional API accounts from sending mail signed by your domain.
   */ this.verifyDomain = function(body) {
        return this.apiClient.post("/senders/verify-domain", body);
    };
};


/***/ }),

/***/ 57833:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add subaccount
   * Add a new subaccount.
   */ this.add = function(body) {
        return this.apiClient.post("/subaccounts/add", body);
    };
    /**
   * Delete subaccount
   * Delete an existing subaccount. Any email related to the subaccount will be saved, but stats will be removed and any future sending calls to this subaccount will fail.
   */ this.delete = function(body) {
        return this.apiClient.post("/subaccounts/delete", body);
    };
    /**
   * Get subaccount info
   * Given the ID of an existing subaccount, return the data about it.
   */ this.info = function(body) {
        return this.apiClient.post("/subaccounts/info", body);
    };
    /**
   * List subaccounts
   * Get the list of subaccounts defined for the account, optionally filtered by a prefix.
   */ this.list = function(body) {
        return this.apiClient.post("/subaccounts/list", body);
    };
    /**
   * Pause subaccount
   * Pause a subaccount's sending. Any future emails delivered to this subaccount will be queued for a maximum of 3 days until the subaccount is resumed.
   */ this.pause = function(body) {
        return this.apiClient.post("/subaccounts/pause", body);
    };
    /**
   * Resume subaccount
   * Resume a paused subaccount's sending.
   */ this.resume = function(body) {
        return this.apiClient.post("/subaccounts/resume", body);
    };
    /**
   * Update subaccount
   * Update an existing subaccount.
   */ this.update = function(body) {
        return this.apiClient.post("/subaccounts/update", body);
    };
};


/***/ }),

/***/ 97045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * View all tags history
   * Return the recent history (hourly stats for the last 30 days) for all tags.
   */ this.allTimeSeries = function(body) {
        return this.apiClient.post("/tags/all-time-series", body);
    };
    /**
   * Delete tag
   * Deletes a tag permanently. Deleting a tag removes the tag from any messages that have been sent, and also deletes the tag's stats. There is no way to undo this operation, so use it carefully.
   */ this.delete = function(body) {
        return this.apiClient.post("/tags/delete", body);
    };
    /**
   * Get tag info
   * Return more detailed information about a single tag, including aggregates of recent stats.
   */ this.info = function(body) {
        return this.apiClient.post("/tags/info", body);
    };
    /**
   * List tags
   * Return all of the user-defined tag information.
   */ this.list = function(body) {
        return this.apiClient.post("/tags/list", body);
    };
    /**
   * View tag history
   * Return the recent history (hourly stats for the last 30 days) for a tag.
   */ this.timeSeries = function(body) {
        return this.apiClient.post("/tags/time-series", body);
    };
};


/***/ }),

/***/ 56802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add template
   * Add a new template.
   */ this.add = function(body) {
        return this.apiClient.post("/templates/add", body);
    };
    /**
   * Delete template
   * Delete a template.
   */ this.delete = function(body) {
        return this.apiClient.post("/templates/delete", body);
    };
    /**
   * Get template info
   * Get the information for an existing template.
   */ this.info = function(body) {
        return this.apiClient.post("/templates/info", body);
    };
    /**
   * List templates
   * Return a list of all the templates available to this user.
   */ this.list = function(body) {
        return this.apiClient.post("/templates/list", body);
    };
    /**
   * Publish template content
   * Publish the content for the template. Any new messages sent using this template will start using the content that was previously in draft.
   */ this.publish = function(body) {
        return this.apiClient.post("/templates/publish", body);
    };
    /**
   * Render html template
   * Inject content and optionally merge fields into a template, returning the HTML that results.
   */ this.render = function(body) {
        return this.apiClient.post("/templates/render", body);
    };
    /**
   * Get template history
   * Return the recent history (hourly stats for the last 30 days) for a template.
   */ this.timeSeries = function(body) {
        return this.apiClient.post("/templates/time-series", body);
    };
    /**
   * Update template
   * Update the code for an existing template. If null is provided for any fields, the values will remain unchanged.
   */ this.update = function(body) {
        return this.apiClient.post("/templates/update", body);
    };
};


/***/ }),

/***/ 92929:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add tracking domains
   * Add a tracking domain to your account.
   */ this.addTrackingDomain = function(body) {
        return this.apiClient.post("/urls/add-tracking-domain", body);
    };
    /**
   * Check cname settings
   * Checks the CNAME settings for a tracking domain. The domain must have been added already with the add-tracking-domain call.
   */ this.checkTrackingDomain = function(body) {
        return this.apiClient.post("/urls/check-tracking-domain", body);
    };
    /**
   * List most clicked urls
   * Get the 100 most clicked URLs.
   */ this.list = function(body) {
        return this.apiClient.post("/urls/list", body);
    };
    /**
   * Search most clicked urls
   * Return the 100 most clicked URLs that match the search query given.
   */ this.search = function(body) {
        return this.apiClient.post("/urls/search", body);
    };
    /**
   * Get url history
   * Return the recent history (hourly stats for the last 30 days) for a URL
   */ this.timeSeries = function(body) {
        return this.apiClient.post("/urls/time-series", body);
    };
    /**
   * List tracking domains
   * Get the list of tracking domains set up for this account.
   */ this.trackingDomains = function(body) {
        return this.apiClient.post("/urls/tracking-domains", body);
    };
};


/***/ }),

/***/ 18894:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Get user info
   * Return the information about the API-connected user.
   */ this.info = function(body) {
        return this.apiClient.post("/users/info", body);
    };
    /**
   * Ping
   * Validate an API key and respond to a ping.
   */ this.ping = function(body) {
        return this.apiClient.post("/users/ping", body);
    };
    /**
   * Ping 2
   * Validate an API key and respond to a ping (JSON parser version).
   */ this.ping2 = function(body) {
        return this.apiClient.post("/users/ping2", body);
    };
    /**
   * List account senders
   * Return the senders that have tried to use this account, both verified and unverified.
   */ this.senders = function(body) {
        return this.apiClient.post("/users/senders", body);
    };
};


/***/ }),

/***/ 5597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add webhook
   * Add a new webhook.
   */ this.add = function(body) {
        return this.apiClient.post("/webhooks/add", body);
    };
    /**
   * Delete webhook
   * Delete an existing webhook.
   */ this.delete = function(body) {
        return this.apiClient.post("/webhooks/delete", body);
    };
    /**
   * Get webhook info
   * Given the ID of an existing webhook, return the data about it.
   */ this.info = function(body) {
        return this.apiClient.post("/webhooks/info", body);
    };
    /**
   * List webhooks
   * Get the list of all webhooks defined on the account.
   */ this.list = function(body) {
        return this.apiClient.post("/webhooks/list", body);
    };
    /**
   * Update webhook
   * Update an existing webhook.
   */ this.update = function(body) {
        return this.apiClient.post("/webhooks/update", body);
    };
};


/***/ }),

/***/ 38226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance();
    /**
   * Add email to allowlist
   * Adds an email to your email rejection allowlist. If the address is currently on your denylist, that denylist entry will be removed automatically.
   */ this.add = function(body) {
        return this.apiClient.post("/whitelists/add", body);
    };
    /**
   * Remove email from allowlist
   * Removes an email address from the allowlist.
   */ this.delete = function(body) {
        return this.apiClient.post("/whitelists/delete", body);
    };
    /**
   * List allowlisted emails
   * Retrieves your email rejection allowlist. You can provide an email address or search prefix to limit the results. Returns up to 1000 results.
   */ this.list = function(body) {
        return this.apiClient.post("/whitelists/list", body);
    };
};


/***/ }),

/***/ 38792:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var ApiClient = __webpack_require__(45708);
module.exports = function(apiKey) {
    return ApiClient.instance(apiKey);
};


/***/ }),

/***/ 43956:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


module.exports = __webpack_require__(12688);


/***/ }),

/***/ 55252:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
var settle = __webpack_require__(6975);
var buildFullPath = __webpack_require__(84416);
var buildURL = __webpack_require__(86857);
var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var httpFollow = (__webpack_require__(64932).http);
var httpsFollow = (__webpack_require__(64932).https);
var url = __webpack_require__(57310);
var zlib = __webpack_require__(59796);
var pkg = __webpack_require__(20971);
var createError = __webpack_require__(32128);
var enhanceError = __webpack_require__(95028);
var isHttps = /https:?/;
/**
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} proxy
 * @param {string} location
 */ function setProxy(options, proxy, location) {
    options.hostname = proxy.host;
    options.host = proxy.host;
    options.port = proxy.port;
    options.path = location;
    // Basic proxy authorization
    if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    // If a proxy is used, any redirects must also pass through the proxy
    options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
    };
}
/*eslint consistent-return:0*/ module.exports = function httpAdapter(config) {
    return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var resolve = function resolve(value) {
            resolvePromise(value);
        };
        var reject = function reject(value) {
            rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        // Set User-Agent (required by some servers)
        // See https://github.com/axios/axios/issues/69
        if ("User-Agent" in headers || "user-agent" in headers) {
            // User-Agent is specified; handle case where no UA header is desired
            if (!headers["User-Agent"] && !headers["user-agent"]) {
                delete headers["User-Agent"];
                delete headers["user-agent"];
            }
        // Otherwise, use specified value
        } else {
            // Only set header if it hasn't been set in config
            headers["User-Agent"] = "axios/" + pkg.version;
        }
        if (data && !utils.isStream(data)) {
            if (Buffer.isBuffer(data)) {
            // Nothing to do...
            } else if (utils.isArrayBuffer(data)) {
                data = Buffer.from(new Uint8Array(data));
            } else if (utils.isString(data)) {
                data = Buffer.from(data, "utf-8");
            } else {
                return reject(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config));
            }
            // Add Content-Length header if data exists
            headers["Content-Length"] = data.length;
        }
        // HTTP basic authentication
        var auth = undefined;
        if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password || "";
            auth = username + ":" + password;
        }
        // Parse url
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
            var urlAuth = parsed.auth.split(":");
            var urlUsername = urlAuth[0] || "";
            var urlPassword = urlAuth[1] || "";
            auth = urlUsername + ":" + urlPassword;
        }
        if (auth) {
            delete headers.Authorization;
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        var options = {
            path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
            method: config.method.toUpperCase(),
            headers: headers,
            agent: agent,
            agents: {
                http: config.httpAgent,
                https: config.httpsAgent
            },
            auth: auth
        };
        if (config.socketPath) {
            options.socketPath = config.socketPath;
        } else {
            options.hostname = parsed.hostname;
            options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
            var proxyEnv = protocol.slice(0, -1) + "_proxy";
            var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
            if (proxyUrl) {
                var parsedProxyUrl = url.parse(proxyUrl);
                var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
                var shouldProxy = true;
                if (noProxyEnv) {
                    var noProxy = noProxyEnv.split(",").map(function trim(s) {
                        return s.trim();
                    });
                    shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                        if (!proxyElement) {
                            return false;
                        }
                        if (proxyElement === "*") {
                            return true;
                        }
                        if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                            return true;
                        }
                        return parsed.hostname === proxyElement;
                    });
                }
                if (shouldProxy) {
                    proxy = {
                        host: parsedProxyUrl.hostname,
                        port: parsedProxyUrl.port,
                        protocol: parsedProxyUrl.protocol
                    };
                    if (parsedProxyUrl.auth) {
                        var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                        proxy.auth = {
                            username: proxyUrlAuth[0],
                            password: proxyUrlAuth[1]
                        };
                    }
                }
            }
        }
        if (proxy) {
            options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
            setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
            transport = config.transport;
        } else if (config.maxRedirects === 0) {
            transport = isHttpsProxy ? https : http;
        } else {
            if (config.maxRedirects) {
                options.maxRedirects = config.maxRedirects;
            }
            transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
            options.maxBodyLength = config.maxBodyLength;
        }
        // Create the request
        var req = transport.request(options, function handleResponse(res) {
            if (req.aborted) return;
            // uncompress the response body transparently if required
            var stream = res;
            // return the last request in case of redirects
            var lastRequest = res.req || req;
            // if no content, is HEAD request or decompress disabled we should not decompress
            if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
                switch(res.headers["content-encoding"]){
                    /*eslint default-case:0*/ case "gzip":
                    case "compress":
                    case "deflate":
                        // add the unzipper to the body stream processing pipeline
                        stream = stream.pipe(zlib.createUnzip());
                        // remove the content-encoding in order to not confuse downstream operations
                        delete res.headers["content-encoding"];
                        break;
                }
            }
            var response = {
                status: res.statusCode,
                statusText: res.statusMessage,
                headers: res.headers,
                config: config,
                request: lastRequest
            };
            if (config.responseType === "stream") {
                response.data = stream;
                settle(resolve, reject, response);
            } else {
                var responseBuffer = [];
                var totalResponseBytes = 0;
                stream.on("data", function handleStreamData(chunk) {
                    responseBuffer.push(chunk);
                    totalResponseBytes += chunk.length;
                    // make sure the content length is not over the maxContentLength if specified
                    if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                        stream.destroy();
                        reject(createError("maxContentLength size of " + config.maxContentLength + " exceeded", config, null, lastRequest));
                    }
                });
                stream.on("error", function handleStreamError(err) {
                    if (req.aborted) return;
                    reject(enhanceError(err, config, null, lastRequest));
                });
                stream.on("end", function handleStreamEnd() {
                    var responseData = Buffer.concat(responseBuffer);
                    if (config.responseType !== "arraybuffer") {
                        responseData = responseData.toString(config.responseEncoding);
                        if (!config.responseEncoding || config.responseEncoding === "utf8") {
                            responseData = utils.stripBOM(responseData);
                        }
                    }
                    response.data = responseData;
                    settle(resolve, reject, response);
                });
            }
        });
        // Handle errors
        req.on("error", function handleRequestError(err) {
            if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS") return;
            reject(enhanceError(err, config, null, req));
        });
        // Handle request timeout
        if (config.timeout) {
            // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
            var timeout = parseInt(config.timeout, 10);
            if (isNaN(timeout)) {
                reject(createError("error trying to parse `config.timeout` to int", config, "ERR_PARSE_TIMEOUT", req));
                return;
            }
            // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
            // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
            // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
            // And then these socket which be hang up will devoring CPU little by little.
            // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
            req.setTimeout(timeout, function handleRequestTimeout() {
                req.abort();
                reject(createError("timeout of " + timeout + "ms exceeded", config, config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", req));
            });
        }
        if (config.cancelToken) {
            // Handle cancellation
            config.cancelToken.promise.then(function onCanceled(cancel) {
                if (req.aborted) return;
                req.abort();
                reject(cancel);
            });
        }
        // Send the request
        if (utils.isStream(data)) {
            data.on("error", function handleStreamError(err) {
                reject(enhanceError(err, config, null, req));
            }).pipe(req);
        } else {
            req.end(data);
        }
    });
};


/***/ }),

/***/ 89654:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
var settle = __webpack_require__(6975);
var cookies = __webpack_require__(14921);
var buildURL = __webpack_require__(86857);
var buildFullPath = __webpack_require__(84416);
var parseHeaders = __webpack_require__(4661);
var isURLSameOrigin = __webpack_require__(16207);
var createError = __webpack_require__(32128);
module.exports = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"]; // Let the browser set it
        }
        var request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) {
                return;
            }
            // Prepare the response
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config: config,
                request: request
            };
            settle(resolve, reject, response);
            // Clean up request
            request = null;
        }
        if ("onloadend" in request) {
            // Use onloadend if available
            request.onloadend = onloadend;
        } else {
            // Listen for ready state to emulate onloadend
            request.onreadystatechange = function handleLoad() {
                if (!request || request.readyState !== 4) {
                    return;
                }
                // The request errored out and we didn't get a response, this will be
                // handled by onerror instead
                // With one exception: request that using file: protocol, most browsers
                // will return status as 0 even though it's a successful request
                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                    return;
                }
                // readystate handler is calling before onerror or ontimeout handlers,
                // so we should call onloadend on the next 'tick'
                setTimeout(onloadend);
            };
        }
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) {
                return;
            }
            reject(createError("Request aborted", config, "ECONNABORTED", request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(createError("Network Error", config, null, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
            if (config.timeoutErrorMessage) {
                timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
            // Add xsrf header
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;
            if (xsrfValue) {
                requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
        }
        // Add headers to the request
        if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                    // Remove Content-Type if data is undefined
                    delete requestHeaders[key];
                } else {
                    // Otherwise add header to the request
                    request.setRequestHeader(key, val);
                }
            });
        }
        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
        }
        // Add responseType to request if needed
        if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
        }
        // Handle progress if needed
        if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
        }
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
            // Handle cancellation
            config.cancelToken.promise.then(function onCanceled(cancel) {
                if (!request) {
                    return;
                }
                request.abort();
                reject(cancel);
                // Clean up request
                request = null;
            });
        }
        if (!requestData) {
            requestData = null;
        }
        // Send the request
        request.send(requestData);
    });
};


/***/ }),

/***/ 12688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
var bind = __webpack_require__(34278);
var Axios = __webpack_require__(76514);
var mergeConfig = __webpack_require__(79612);
var defaults = __webpack_require__(74050);
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    // Copy axios.prototype to instance
    utils.extend(instance, Axios.prototype, context);
    // Copy context to instance
    utils.extend(instance, context);
    return instance;
}
// Create the default instance to be exported
var axios = createInstance(defaults);
// Expose Axios class to allow class inheritance
axios.Axios = Axios;
// Factory for creating new instances
axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
};
// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(31854);
axios.CancelToken = __webpack_require__(31343);
axios.isCancel = __webpack_require__(41710);
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = __webpack_require__(63205);
// Expose isAxiosError
axios.isAxiosError = __webpack_require__(26585);
module.exports = axios;
// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ 31854:
/***/ ((module) => {


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */ function Cancel(message) {
    this.message = message;
}
Cancel.prototype.toString = function toString() {
    return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;


/***/ }),

/***/ 31343:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Cancel = __webpack_require__(31854);
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */ function CancelToken(executor) {
    if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
        if (token.reason) {
            // Cancellation has already been requested
            return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
    });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */ CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
        throw this.reason;
    }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */ CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
        cancel = c;
    });
    return {
        token: token,
        cancel: cancel
    };
};
module.exports = CancelToken;


/***/ }),

/***/ 41710:
/***/ ((module) => {


module.exports = function isCancel(value) {
    return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ 76514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
var buildURL = __webpack_require__(86857);
var InterceptorManager = __webpack_require__(66013);
var dispatchRequest = __webpack_require__(53539);
var mergeConfig = __webpack_require__(79612);
var validator = __webpack_require__(58765);
var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */ function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
    };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */ Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
    } else {
        config = config || {};
    }
    config = mergeConfig(this.defaults, config);
    // Set config.method
    if (config.method) {
        config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
    } else {
        config.method = "get";
    }
    var transitional = config.transitional;
    if (transitional !== undefined) {
        validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
            forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
            clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
        }, false);
    }
    // filter out skipped interceptors
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    if (!synchronousRequestInterceptors) {
        var chain = [
            dispatchRequest,
            undefined
        ];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while(chain.length){
            promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
    }
    var newConfig = config;
    while(requestInterceptorChain.length){
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
            newConfig = onFulfilled(newConfig);
        } catch (error) {
            onRejected(error);
            break;
        }
    }
    try {
        promise = dispatchRequest(newConfig);
    } catch (error) {
        return Promise.reject(error);
    }
    while(responseInterceptorChain.length){
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise;
};
Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
};
// Provide aliases for supported request methods
utils.forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
            method: method,
            url: url,
            data: (config || {}).data
        }));
    };
});
utils.forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
            method: method,
            url: url,
            data: data
        }));
    };
});
module.exports = Axios;


/***/ }),

/***/ 66013:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
function InterceptorManager() {
    this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */ InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */ InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
        this.handlers[id] = null;
    }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */ InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
            fn(h);
        }
    });
};
module.exports = InterceptorManager;


/***/ }),

/***/ 84416:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isAbsoluteURL = __webpack_require__(20938);
var combineURLs = __webpack_require__(38858);
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */ module.exports = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
};


/***/ }),

/***/ 32128:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var enhanceError = __webpack_require__(95028);
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */ module.exports = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ 53539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
var transformData = __webpack_require__(20795);
var isCancel = __webpack_require__(41710);
var defaults = __webpack_require__(74050);
/**
 * Throws a `Cancel` if cancellation has been requested.
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
    }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */ module.exports = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    // Ensure headers exist
    config.headers = config.headers || {};
    // Transform request data
    config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
    // Flatten headers
    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils.forEach([
        "delete",
        "get",
        "head",
        "post",
        "put",
        "patch",
        "common"
    ], function cleanHeaderConfig(method) {
        delete config.headers[method];
    });
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
    }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
            }
        }
        return Promise.reject(reason);
    });
};


/***/ }),

/***/ 95028:
/***/ ((module) => {


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */ module.exports = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
        error.code = code;
    }
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code
        };
    };
    return error;
};


/***/ }),

/***/ 79612:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */ module.exports = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = [
        "url",
        "method",
        "data"
    ];
    var mergeDeepPropertiesKeys = [
        "headers",
        "auth",
        "proxy",
        "params"
    ];
    var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
    ];
    var directMergeKeys = [
        "validateStatus"
    ];
    function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
        } else if (utils.isArray(source)) {
            return source.slice();
        }
        return source;
    }
    function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(undefined, config1[prop]);
        }
    }
    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(undefined, config2[prop]);
        }
    });
    utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(undefined, config1[prop]);
        }
    });
    utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
            config[prop] = getMergedValue(undefined, config1[prop]);
        }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
    });
    utils.forEach(otherKeys, mergeDeepProperties);
    return config;
};


/***/ }),

/***/ 6975:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var createError = __webpack_require__(32128);
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */ module.exports = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
    } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
    }
};


/***/ }),

/***/ 20795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
var defaults = __webpack_require__(74050);
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */ module.exports = function transformData(data, headers, fns) {
    var context = this || defaults;
    /*eslint no-param-reassign:0*/ utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
    });
    return data;
};


/***/ }),

/***/ 74050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
var normalizeHeaderName = __webpack_require__(66412);
var enhanceError = __webpack_require__(95028);
var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
    }
}
function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
        // For browsers use XHR adapter
        adapter = __webpack_require__(89654);
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        // For node use HTTP adapter
        adapter = __webpack_require__(55252);
    }
    return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
    if (utils.isString(rawValue)) {
        try {
            (parser || JSON.parse)(rawValue);
            return utils.trim(rawValue);
        } catch (e) {
            if (e.name !== "SyntaxError") {
                throw e;
            }
        }
    }
    return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
    transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
    },
    adapter: getDefaultAdapter(),
    transformRequest: [
        function transformRequest(data, headers) {
            normalizeHeaderName(headers, "Accept");
            normalizeHeaderName(headers, "Content-Type");
            if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
                return data;
            }
            if (utils.isArrayBufferView(data)) {
                return data.buffer;
            }
            if (utils.isURLSearchParams(data)) {
                setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
                return data.toString();
            }
            if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
                setContentTypeIfUnset(headers, "application/json");
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            var transitional = this.transitional;
            var silentJSONParsing = transitional && transitional.silentJSONParsing;
            var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
            if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") {
                            throw enhanceError(e, this, "E_JSON_PARSE");
                        }
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    }
};
defaults.headers = {
    common: {
        "Accept": "application/json, text/plain, */*"
    }
};
utils.forEach([
    "delete",
    "get",
    "head"
], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
});
utils.forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;


/***/ }),

/***/ 34278:
/***/ ((module) => {


module.exports = function bind(fn, thisArg) {
    return function wrap() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
    };
};


/***/ }),

/***/ 86857:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */ module.exports = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/ if (!params) {
        return url;
    }
    var serializedParams;
    if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
    } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
                return;
            }
            if (utils.isArray(val)) {
                key = key + "[]";
            } else {
                val = [
                    val
                ];
            }
            utils.forEach(val, function parseValue(v) {
                if (utils.isDate(v)) {
                    v = v.toISOString();
                } else if (utils.isObject(v)) {
                    v = JSON.stringify(v);
                }
                parts.push(encode(key) + "=" + encode(v));
            });
        });
        serializedParams = parts.join("&");
    }
    if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
};


/***/ }),

/***/ 38858:
/***/ ((module) => {


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */ module.exports = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};


/***/ }),

/***/ 14921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
    return {
        write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
                cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
                cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
                cookie.push("domain=" + domain);
            }
            if (secure === true) {
                cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
        },
        read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
            this.write(name, "", Date.now() - 86400000);
        }
    };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return {
        write: function write() {},
        read: function read() {
            return null;
        },
        remove: function remove() {}
    };
}();


/***/ }),

/***/ 20938:
/***/ ((module) => {


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */ module.exports = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ 26585:
/***/ ((module) => {


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */ module.exports = function isAxiosError(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
};


/***/ }),

/***/ 16207:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        var href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();


/***/ }),

/***/ 66412:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
module.exports = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
        }
    });
};


/***/ }),

/***/ 4661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var utils = __webpack_require__(2316);
// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */ module.exports = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
        return parsed;
    }
    utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                return;
            }
            if (key === "set-cookie") {
                parsed[key] = (parsed[key] ? parsed[key] : []).concat([
                    val
                ]);
            } else {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
        }
    });
    return parsed;
};


/***/ }),

/***/ 63205:
/***/ ((module) => {


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */ module.exports = function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
};


/***/ }),

/***/ 58765:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var pkg = __webpack_require__(20971);
var validators = {};
// eslint-disable-next-line func-names
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach(function(type, i) {
    validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split(".");
/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */ function isOlderVersion(version, thanVersion) {
    var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
    var destVer = version.split(".");
    for(var i = 0; i < 3; i++){
        if (pkgVersionArr[i] > destVer[i]) {
            return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
            return false;
        }
    }
    return false;
}
/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    var isDeprecated = version && isOlderVersion(version);
    function formatMessage(opt, desc) {
        return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    // eslint-disable-next-line func-names
    return function(value, opt, opts) {
        if (validator === false) {
            throw new Error(formatMessage(opt, " has been removed in " + version));
        }
        if (isDeprecated && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
        throw new TypeError("options must be an object");
    }
    var keys = Object.keys(options);
    var i = keys.length;
    while(i-- > 0){
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
            var value = options[opt];
            var result = value === undefined || validator(value, opt, options);
            if (result !== true) {
                throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
        }
        if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
        }
    }
}
module.exports = {
    isOlderVersion: isOlderVersion,
    assertOptions: assertOptions,
    validators: validators
};


/***/ }),

/***/ 2316:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var bind = __webpack_require__(34278);
// utils is a library of generic helper functions non-specific to axios
var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */ function isArray(val) {
    return toString.call(val) === "[object Array]";
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */ function isUndefined(val) {
    return typeof val === "undefined";
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ function isArrayBuffer(val) {
    return toString.call(val) === "[object ArrayBuffer]";
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */ function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
    } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */ function isString(val) {
    return typeof val === "string";
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */ function isNumber(val) {
    return typeof val === "number";
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */ function isObject(val) {
    return val !== null && typeof val === "object";
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */ function isPlainObject(val) {
    if (toString.call(val) !== "[object Object]") {
        return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */ function isDate(val) {
    return toString.call(val) === "[object Date]";
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */ function isFile(val) {
    return toString.call(val) === "[object File]";
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */ function isBlob(val) {
    return toString.call(val) === "[object Blob]";
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ function isFunction(val) {
    return toString.call(val) === "[object Function]";
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */ function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */ function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */ function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
    }
    return  false && 0;
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */ function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") {
        return;
    }
    // Force an array if not already something iterable
    if (typeof obj !== "object") {
        /*eslint no-param-reassign:0*/ obj = [
            obj
        ];
    }
    if (isArray(obj)) {
        // Iterate over array values
        for(var i = 0, l = obj.length; i < l; i++){
            fn.call(null, obj[i], i, obj);
        }
    } else {
        // Iterate over object keys
        for(var key in obj){
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                fn.call(null, obj[key], key, obj);
            }
        }
    }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */ function merge() {
    var result = {};
    function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
            result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
            result[key] = merge({}, val);
        } else if (isArray(val)) {
            result[key] = val.slice();
        } else {
            result[key] = val;
        }
    }
    for(var i = 0, l = arguments.length; i < l; i++){
        forEach(arguments[i], assignValue);
    }
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */ function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
        } else {
            a[key] = val;
        }
    });
    return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */ function stripBOM(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
    }
    return content;
}
module.exports = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM
};


/***/ }),

/***/ 20971:
/***/ ((module) => {

module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ })

};
;